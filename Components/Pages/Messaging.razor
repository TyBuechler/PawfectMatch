@page "/messaging"
@using PawfectMatch.Components.Services

@attribute [StreamRendering]
@rendermode InteractiveServer

@inject IMessagingBrokerClient client

<h2>Messaging</h2>

<!-- Messaging Producer Section -->
<h3>Messaging Producer</h3>
<div class="col-md-6 w-70">
    <label class="form-label">Subject:</label>
    <InputText @bind-Value="topicName" class="px-sm-2 w-70" />
    <Spinner Class="me-3" Visible="isLoading" Type="SpinnerType.Dots" Color="SpinnerColor.Danger" Size="SpinnerSize.ExtraLarge" />

    <Button Color="ButtonColor.Primary" class="me-2" Disabled="@(string.IsNullOrEmpty(topicName) || string.IsNullOrEmpty(messageContent))" @onclick="publish">
        Publish
    </Button><p />
</div>

<div class="col-md-6 w-50">
    <InputTextArea @bind-Value="@messageContent" rows="5" class="px-md-2 border-1 w-100"></InputTextArea>
</div>

<!-- Messaging Consumer Section -->
<h3>Your Messages</h3>
<div class="col-md-6 w-70">
    <label class="form-label">Search by Subject:</label>
    <InputText @bind-Value="consumeTopicName" class="px-sm-2 w-70" />
    <Spinner Class="me-3" Visible="isLoading" Type="SpinnerType.Dots" Color="SpinnerColor.Danger" Size="SpinnerSize.ExtraLarge" />

    <Button Color="ButtonColor.Primary" class="me-2" Disabled="@(string.IsNullOrEmpty(consumeTopicName))" @onclick="startConsume">
        @Title
    </Button><p />
</div>

<!-- Events List -->
<h5> Events:</h5>
<ul class="list-group">
    @foreach (var eventTrack in events)
    {
        <li class="list-group-item">
            <strong>@eventTrack.EventTime.ToString("g")</strong> - <strong>@eventTrack.Topic</strong>: 
            <span class="@(eventTrack.IsError ? "text-danger" : "text-primary")">@eventTrack.Message</span>
        </li>
    }
</ul>

@code {
    private bool isLoading = default!;
    record EventTrack(DateTime EventTime, string Topic, string Message, bool IsError = false);
    private List<EventTrack> events = new();

    // Publish part
    private string? messageContent = "sample text to publish to selected topic";
    private string? topicName = default!;

    // Consume part
    private string? consumeTopicName = default!;
    private bool isStarted = false;
    private string Title => !isStarted ? "Start Listening" : "Stop Listening";
    private CancellationToken token;
    private CancellationTokenSource source;

    protected override async Task OnInitializedAsync()
    {
        events.Add(new(DateTime.Now, "web app", "Initialized"));
        source = new CancellationTokenSource();
        token = source.Token;

        client.MessageConsumed += MessageConsumedEvent!;
    }

    private async Task publish()
    {
        var result = await client.PublishAsync(topicName!, messageContent!);
        events.Add(new(DateTime.Now, topicName! + " topic", "Published new message"));
        events.Add(new(DateTime.Now, topicName! + " topic", result));
        StateHasChanged();
    }

    private async Task MessageConsumedEvent(object sender, string e)
    {
        await InvokeAsync(() =>
        {
            events.Add(new(DateTime.Now, consumeTopicName! + " topic", e));
            StateHasChanged();
        });
    }

    private async Task startConsume()
    {
        if (!isStarted)
        {
            await InvokeAsync(() =>
            {
                client.StartListeningAsync(consumeTopicName!, token);
                events.Add(new(DateTime.Now, "web app", "Started listening..."));
                isStarted = true;
            });
        }
        else
        {
            source.Cancel();
            client.StopListening(token);
            isStarted = false;
        }
    }
}